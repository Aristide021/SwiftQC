# Understanding Command Sequences in Stateful Testing

When performing stateful tests with SwiftQC's `stateful` runner, the results, especially in the case of failures, are presented in terms of command sequences. Understanding these structures is key to interpreting test outcomes.

These types are defined in `Sources/SwiftQC/Stateful/Commands.swift`.

## `ExecutedCommand<Model: StateModel>`

The `ExecutedCommand` struct captures all relevant information about a single step (a single command execution) within a test sequence. It's `Sendable` provided all of the `Model`'s associated types are `Sendable`.

```swift
public struct ExecutedCommand<Model: StateModel>: Sendable where
    Model.CommandVar: Sendable,
    Model.CommandConcrete: Sendable,
    Model.ResponseVar: Sendable,
    Model.ResponseConcrete: Sendable,
    Model.State: Sendable
{
    /// The symbolic command as generated by `Model.generateCommand`.
    public let symbolicCommand: Model.CommandVar

    /// The concrete command that was actually executed on the SUT,
    /// after resolving any symbolic references.
    public let concreteCommand: Model.CommandConcrete

    /// The symbolic response predicted by `Model.runFake`.
    public let modelResponse: Model.ResponseVar

    /// The concrete response received from the SUT via `Model.runReal`.
    /// This is now an optional type (`Model.ResponseConcrete?`) to reflect that
    /// `runReal` might throw an error (in which case `actualResponse` will be `nil`),
    /// or the SUT might legitimately return `nil` if `ResponseConcrete` itself is an Optional type.
    public let actualResponse: Model.ResponseConcrete?

    /// The model's state *before* this command was executed (in the model).
    public let stateBefore: Model.State

    /// The model's state *after* this command was executed (in the model).
    public let stateAfter: Model.State

    // Public initializer
    public init(
        symbolicCommand: Model.CommandVar,
        concreteCommand: Model.CommandConcrete,
        modelResponse: Model.ResponseVar,
        actualResponse: Model.ResponseConcrete?, // Updated to optional
        stateBefore: Model.State,
        stateAfter: Model.State
    ) { /* ... */ }
}
```

Each instance of `ExecutedCommand` provides a complete snapshot of what was intended (symbolic command, model response), what actually happened (concrete command, SUT response), and the model's state transition.

## `CommandSequence<Model: StateModel>`

The `CommandSequence` struct represents an entire sequence of commands that were executed, leading to either a successful validation or a failure. This is the type carried by `TestResult.falsified` from the `stateful` runner. It is also `Sendable` under the same conditions as `ExecutedCommand`.

```swift
public struct CommandSequence<Model: StateModel>: Sendable where
    Model.CommandVar: Sendable,
    Model.CommandConcrete: Sendable,
    Model.ResponseVar: Sendable,
    Model.ResponseConcrete: Sendable,
    Model.State: Sendable
{
    /// The initial state of the model before any commands in this sequence were run.
    public let initialState: Model.State

    /// An array of `ExecutedCommand` structs, representing each step in the sequence.
    /// For a failing sequence, this will be the *minimal* sequence found by the shrinker.
    public let steps: [ExecutedCommand<Model>]

    /// The final state of the model after all commands in this sequence were executed.
    public let finalModelState: Model.State

    // Public initializer
    public init(
        initialState: Model.State,
        steps: [ExecutedCommand<Model>],
        finalModelState: Model.State
    ) { /* ... */ }
}
```

### Interpreting a Failing `CommandSequence`

When a stateful test fails, the `TestResult.falsified(value: CommandSequence<Model>, ...)` provides the minimal `CommandSequence` that reproduced the error. To debug:

1.  **Examine the `seed`:** Use this seed to reproduce the failure deterministically.
2.  **Inspect `steps`:** Iterate through the `steps` array in the `CommandSequence`.
    *   Look at the `concreteCommand` that was run.
    *   Compare `modelResponse` to `actualResponse`. The point of divergence or the SUT error will be indicated here.
    *   `stateBefore` and `stateAfter` show the model's view of the state transitions.
3.  **The last command in a failing sequence is often the one that directly triggered the SUT error or the response divergence.** The preceding commands set up the state that led to the failure.

The console output from SwiftQC's `stateful` runner during a failure and shrinking also provides a human-readable version of this sequence, aiding in quick diagnosis. For example:

```
ðŸ”¥ Minimal counterexample for property 'Buggy Counter Model Divergence Test' found with input 'CommandSequence<BuggyCounterModel>(initialState: 0, steps: [
    SwiftQC.ExecutedCommand<SwiftQCTests.BuggyCounterModel>(symbolicCommand: getValue, concreteCommand: getValue, modelResponse: value(0), actualResponse: value(0), stateBefore: 0, stateAfter: 0), 
    SwiftQC.ExecutedCommand<SwiftQCTests.BuggyCounterModel>(symbolicCommand: increment, concreteCommand: increment, modelResponse: ackIncrement, actualResponse: ackIncrement, stateBefore: 0, stateAfter: 1), 
    SwiftQC.ExecutedCommand<SwiftQCTests.BuggyCounterModel>(symbolicCommand: increment, concreteCommand: increment, modelResponse: ackIncrement, actualResponse: ackIncrement, stateBefore: 1, stateAfter: 2), 
    SwiftQC.ExecutedCommand<SwiftQCTests.BuggyCounterModel>(symbolicCommand: increment, concreteCommand: increment, modelResponse: ackIncrement, actualResponse: ackIncrement, stateBefore: 2, stateAfter: 3), 
    SwiftQC.ExecutedCommand<SwiftQCTests.BuggyCounterModel>(symbolicCommand: getValue, concreteCommand: getValue, modelResponse: value(3), actualResponse: value(8), stateBefore: 3, stateAfter: 3)
], finalModelState: 3)' at SwiftQCTests/StatefulTests.swift:254. Error: Model-SUT Response Divergence. Cmd: getValue, ModelResp: value(3), SUTResp: value(8)
```
This shows the initial state was `0`. After a `getValue` and three `increment`s, the model predicted `getValue` would return `value(3)`, but the SUT returned `value(8)`, causing the failure.
