# Stateful Property-Based Testing with SwiftQC

SwiftQC provides a powerful framework for **stateful property-based testing**, drawing inspiration from established systems like Erlang QuickCheck (Quviq). This approach is invaluable for testing systems that maintain state and whose behavior depends on a sequence of operations performed over time.

The core idea is to:
1.  Define a simplified **model** of your system under test (SUT), including its state, possible commands, and expected responses.
2.  Generate random sequences of **commands** applicable to the current model state.
3.  Execute these commands against both your abstract model and the actual SUT.
4.  Verify that the SUT's responses and resulting state (as reflected by the model) are **consistent** with the model's predictions.
5.  If a discrepancy (divergence) or SUT error is found, SwiftQC automatically attempts to **shrink** the command sequence to the smallest possible list of commands that still reproduces the issue, making debugging much easier.

## The `StateModel` Protocol

At the heart of stateful testing in SwiftQC is the `StateModel` protocol. You conform a type (typically a `struct`) to this protocol to describe the abstract state, commands, responses, and behavior of your system.

```swift
public protocol StateModel {
    // MARK: - Associated Types

    /// The type representing the abstract state of your model.
    /// This state is used by the model to predict outcomes.
    /// It must be `Equatable` for state comparisons during testing and `Sendable`
    /// as it's used by the concurrent `stateful` runner.
    associatedtype State: Equatable, Sendable

    /// A type for symbolic references that can be generated by commands and used by subsequent commands.
    /// For example, if a command creates a user and returns a `UserID`, `ReferenceType` could be `UserID`.
    /// It must conform to `Referenceable` (which implies `Hashable` & `Sendable`).
    /// If your model doesn't use references, you can use the provided `NoReference` type.
    associatedtype ReferenceType: Referenceable

    /// The type representing a command at the symbolic level, as generated by `generateCommand`.
    /// It may contain `Var<ReferenceType>` instances to refer to entities that will be
    /// created during the execution of the command sequence. Must be `Sendable`.
    associatedtype CommandVar: Sendable

    /// The type representing a response at the symbolic level, as predicted by `runFake`.
    /// It may also contain `Var<ReferenceType>` instances. Must be `Sendable`.
    associatedtype ResponseVar: Sendable

    /// The type representing a command at the concrete level, as executed by `runReal` on the SUT.
    /// It contains concrete `ReferenceType` instances. Must be `Sendable`.
    associatedtype CommandConcrete: Sendable

    /// The type representing a response at the concrete level, as returned by `runReal` from the SUT.
    /// It contains concrete `ReferenceType` instances. Must be `Sendable`.
    associatedtype ResponseConcrete: Sendable

    /// The type of the actual System Under Test (SUT) that commands will be run against.
    /// Must be `Sendable` if the `sutFactory` in the `stateful` runner might pass it across
    /// concurrency boundaries or if `runReal` is non-isolated.
    associatedtype SUT: Sendable

    // MARK: - Required Static Properties and Methods

    /// The initial abstract state of the model before any commands are executed.
    static var initialState: State { get }

    /// Generates a `Gen<CommandVar>` that produces a random symbolic command
    /// applicable to the given current model `state`.
    static func generateCommand(_ state: State) -> Gen<CommandVar>

    /// Executes a symbolic command (`CommandVar`) on the abstract model `state`.
    ///
    /// This function should:
    /// 1. Check preconditions: If the command is not valid in the current `state`,
    ///    return `.left(PreconditionFailure(...))`.
    /// 2. If valid, update the model `state` according to the command's semantics.
    /// 3. Return `.right((newState, symbolicResponse))`, where `newState` is the
    ///    updated model state and `symbolicResponse` is the expected response from the model.
    static func runFake(_ cmd: CommandVar, inState state: State) -> Either<PreconditionFailure, (State, ResponseVar)>

    /// Executes a concrete command (`CommandConcrete`) on the actual System Under Test (`SUT`).
    ///
    /// - Parameters:
    ///   - cmd: The concrete command to execute.
    ///   - sut: The instance of the SUT.
    /// - Returns: A `CommandMonad<ResponseConcrete>`, which is an async, throwing closure
    ///   that performs the action on the SUT and returns the concrete response.
    ///   If the SUT operation fails unexpectedly, this closure should throw an error.
    static func runReal(_ cmd: CommandConcrete, sut: SUT) -> CommandMonad<ResponseConcrete>

    /// Converts a symbolic command (`CommandVar`) into a concrete command (`CommandConcrete`).
    ///
    /// This is used to transform commands that might contain symbolic references (like "the ID of the
    /// user created in step 2") into commands that use actual, concrete references resolved from
    /// previous steps.
    ///
    /// - Parameter symbolicCmd: The command with symbolic `Var<ReferenceType>` placeholders.
    /// - Parameter resolver: A function `@Sendable (Var<ReferenceType>) -> ReferenceType` that can
    ///   look up the concrete `ReferenceType` for a given symbolic `Var`.
    /// - Returns: The command with all symbolic references replaced by concrete ones.
    static func concretizeCommand(
        _ symbolicCmd: CommandVar,
        resolver: @Sendable (Var<ReferenceType>) -> ReferenceType
    ) -> CommandConcrete
    
    /// Compares a symbolic response (`ResponseVar` from `runFake`) with a concrete response
    /// (`ResponseConcrete` from `runReal`).
    ///
    /// This function determines if the SUT's behavior matches the model's prediction.
    /// It may need to use the `resolver` if responses also contain references.
    ///
    /// - Returns: `true` if the responses are considered equivalent, `false` otherwise.
    static func areResponsesEquivalent(
        symbolicResponse: ResponseVar,
        concreteResponse: ResponseConcrete,
        resolver: @Sendable (Var<ReferenceType>) -> ReferenceType
    ) -> Bool

    // MARK: - Optional Static Methods (with default implementations)

    /// (Optional) Shrinks an individual symbolic command (`CommandVar`) within the context of a
    /// given model `state`.
    ///
    /// This is used during the shrinking of a failing command sequence to try and simplify
    /// individual commands in that sequence.
    ///
    /// - Default: Returns an empty array (no command-specific shrinking).
    static func shrinkCommand(_ cmd: CommandVar, inState state: State) -> [CommandVar]

    /// (Optional) Extracts newly created concrete references from the SUT's `responseConcrete`
    /// and maps them to their corresponding symbolic `Var`s found in the model's `responseVar`.
    ///
    /// This is essential for testing systems where commands create resources (e.g., a "create user"
    /// command might return a new `UserID`). The stateful runner uses these mappings to populate
    /// its `resolver` for subsequent commands.
    ///
    /// - Default: Returns an empty dictionary (no new references extracted).
    static func extractNewReferences(
        responseVar: ResponseVar,
        responseConcrete: ResponseConcrete
    ) -> [Var<ReferenceType>: ReferenceType]
    
    /// (Optional) Allows for custom monitoring, metrics collection, or classification of test runs
    /// after each command is executed on both the model and the SUT.
    ///
    /// - Default: Returns the input `property` unchanged.
    static func monitoring<PropValue: Sendable>(
        from: (oldState: State, newState: State), // Model state transition
        command: CommandConcrete,                 // Concrete command that was run
        response: ResponseConcrete,               // Concrete response from SUT
        property: Property<PropValue>             // Overall property context
    ) -> Property<PropValue>
}
```

## Helper Types

SwiftQC provides these helpers for use in your `StateModel`:

-   **`Var<ReferenceType>`:** A wrapper for symbolic references. It's `Hashable` to be used as dictionary keys for mapping symbolic to concrete references.
-   **`Referenceable`:** A protocol (`Hashable & Sendable`) that your concrete reference types must conform to.
-   **`PreconditionFailure`:** An `Error` type to return from `runFake` if a command's preconditions are not met.
-   **`Either<Left, Right>`:** Used by `runFake` to return a precondition failure or a success.
-   **`CommandMonad<A>`:** A typealias for `@Sendable () async throws -> A`, representing the asynchronous execution of a command on the SUT.

## Running Stateful Tests

SwiftQC provides the `stateful` function to drive your state machine tests:

```swift
public func stateful<Model: StateModel, SUT_Runner: Sendable>(
    _ propertyName: String,
    sutFactory: @Sendable () async -> SUT_Runner, // Factory to create/reset SUT per sequence
    maxCommandsInSequence: Int = 100,             // Max commands per test sequence
    numberOfSequences: Int = 10,                  // Number of command sequences to run
    seed: UInt64? = nil,
    reporter: Reporter = ConsoleReporter(),
    file: StaticString = #file,
    line: UInt = #line
) async -> TestResult<CommandSequence<Model>>
    where Model.SUT == SUT_Runner,
          // Necessary Sendable constraints for the runner
          Model.State: Sendable, Model.CommandVar: Sendable, Model.ResponseVar: Sendable,
          Model.CommandConcrete: Sendable, Model.ResponseConcrete: Sendable,
          Model.ReferenceType: Sendable
```

**How it Works:**
1.  The `stateful` runner executes `numberOfSequences` test runs.
2.  For each sequence:
    a.  An instance of your `SUT` is created using the `sutFactory`.
    b.  Starting from `Model.initialState`, the runner generates a sequence of up to `maxCommandsInSequence` commands using `Model.generateCommand`.
    c.  For each command:
        i.  It's executed on the model via `Model.runFake`. If a precondition fails, the command is skipped (up to a limit of retries for generating a valid command).
        ii. If `runFake` succeeds, the symbolic command is concretized using `Model.concretizeCommand` (with a resolver for references created in the current sequence).
        iii.The concrete command is executed on the SUT via `Model.runReal`.
        iv. New references from `Model.extractNewReferences` are added to the resolver's map for use by subsequent commands.
        v.  The model's response (`ResponseVar`) is compared to the SUT's response (`ResponseConcrete`) using `Model.areResponsesEquivalent`.
3.  **Failure Conditions:**
    *   If `runReal` throws an unhandled error (SUT error).
    *   If `areResponsesEquivalent` returns `false` (Model-SUT divergence).
4.  **Shrinking:** If a command sequence results in a failure, SwiftQC **automatically attempts to shrink the sequence** to find a minimal failing sub-sequence. This involves trying to remove commands or shrink individual commands (if `shrinkCommand` is implemented) to isolate the simplest set of steps that still reproduce the bug.
5.  **Result:** Returns a `TestResult<CommandSequence<Model>>`. If falsified, the `CommandSequence` in the result will be the *minimal* sequence found that reproduces the failure.

### Example Usage (Conceptual - using the `CounterModel` from tests)

```swift
import SwiftQC
import Testing

// Assume CounterModel and RealCounterSUT are defined as shown in SwiftQCTests/StatefulTests.swift

@Test("@MainActor Counter Stateful Test") // Use @MainActor if SUT requires it
func counterBehavesAsModelled() async {
    // The sutFactory creates a fresh SUT for each command sequence test.
    // Ensure SUT state is reset or new for each sequence.
    // If RealCounterSUT has a reset() method:
    // let mySUT = RealCounterSUT()
    // let factory = { mySUT.reset(); return mySUT }
    // Or for true isolation:
    let factory = { /* await */ RealCounterSUT() } // Ensure SUT is Sendable or factory runs on correct actor

    let result: TestResult<CommandSequence<CounterModel>> = await SwiftQC.stateful(
        "Counter Correctness",
        sutFactory: factory,
        maxCommandsInSequence: 50,
        numberOfSequences: 20
    )

    if case .falsified(let sequence, let error, _, let seed) = result {
        // Log detailed failure information
        var failureLog = "Counter stateful test failed. Seed: \(seed ?? 0).\nError: \(error)\nSequence (StateBefore -> Cmd -> ModelResp/SUTResp -> StateAfter):\n"
        for (index, step) in sequence.steps.enumerated() {
            failureLog += "  [\(index)] \(step.stateBefore) -> \(step.concreteCommand) -> M:\(step.modelResponse)/S:\(step.actualResponse) -> \(step.stateAfter)\n"
        }
        XCTFail(failureLog) // Or use #expect(Bool(false), failureLog) with Swift Testing
    }
}
```
This example demonstrates how to set up and run a stateful test. You would replace `CounterModel` and `RealCounterSUT` with your own system's model and implementation.
